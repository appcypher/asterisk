use serde::{Deserialize, Serialize};
use thiserror::Error;

use crate::models::{AssistantMessage, Prompt, PromptMessage, SystemMessage, UserMessage};

use super::Config;

//--------------------------------------------------------------------------------------------------
// Types: Request
//--------------------------------------------------------------------------------------------------

/// The body of a request to the OpenAI API.
#[derive(Debug, Serialize)]
pub struct RequestBody {
    /// The messages to send to the model.
    pub messages: RequestMessages,

    /// The model's configuration.
    #[serde(flatten)]
    pub config: Config,
}

#[derive(Debug, Serialize)]
/// A collection of messages in a chat conversation with the model.
pub struct RequestMessages(pub Vec<RequestMessage>);

/// A message in a chat conversation with the model.
#[derive(Debug, Serialize)]
#[serde(tag = "role")]
pub enum RequestMessage {
    /// A message that sets the context for the conversation.
    #[serde(rename = "system")]
    System {
        /// The name of the system.
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,

        /// The content of the message.
        content: String,
    },

    /// A message that assumes the role of the user.
    #[serde(rename = "user")]
    User {
        /// The name of the user.
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,

        /// The content of the message.
        content: String,
    },

    /// A message that assumes the role of the assistant.
    #[serde(rename = "assistant")]
    Assistant {
        /// The name of the user.
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,

        /// The content of the message.
        content: String,

        /// Refusal message
        #[serde(skip_serializing_if = "Option::is_none")]
        refusal: Option<String>,
    },
}

//--------------------------------------------------------------------------------------------------
// Types: Response
//--------------------------------------------------------------------------------------------------

/// Response body.
#[derive(Debug, Deserialize)]
#[serde(untagged)]
pub enum ResponseBody {
    /// A successful response.
    Ok(ResponseOk),

    /// An error response.
    Error(ResponseError),
}

/// Represents an error response returned by the OpenAI API.
///
/// See [here](https://github.com/openai/openai-python/blob/9850c169c4126fd04dc6796e4685f1b9e4924aa4/src/openai/types/shared/error_object.py#L10) for more
#[derive(Debug, Deserialize, Error)]
#[error("ollama error: {error}")]
pub struct ResponseError {
    /// The error information.
    pub error: String,
}

/// Represents a successful chat completion response returned by model, based on the provided input.
#[derive(Debug, Deserialize)]
pub struct ResponseOk {
    /// The timestamp of when the chat completion was created.
    pub created_at: String,

    /// The model to generate the completion.
    pub model: String,

    /// The message generated by the model.
    pub message: ResponseMessage,

    /// Whether the model has finished generating the response.
    pub done: bool,

    /// The reason the model stopped generating tokens.
    pub done_reason: String,

    /// The context of the message.
    pub context: Option<Vec<u64>>,

    /// The total duration of the message.
    pub total_duration: u64,

    /// The load duration of the message.
    pub load_duration: u64,

    /// The prompt evaluation count of the message.
    pub prompt_eval_count: u64,

    /// The prompt evaluation duration of the message.
    pub prompt_eval_duration: u64,

    /// The evaluation count of the message.
    pub eval_count: u64,

    /// The evaluation duration of the message.
    pub eval_duration: u64,
}

/// The message generated by the model.
#[derive(Debug, Deserialize)]
pub struct ResponseMessage {
    /// The content of the message.
    pub content: Option<String>,

    /// The role of the message.
    pub role: Option<String>,
}

//--------------------------------------------------------------------------------------------------
// Methods
//--------------------------------------------------------------------------------------------------

impl ResponseBody {
    /// Gets the error variant or panics.
    pub fn unwrap_err(self) -> ResponseError {
        match self {
            ResponseBody::Error(error) => error,
            ResponseBody::Ok(_) => panic!("Called `unwrap_err()` on a `ResponseBody::Ok` value"),
        }
    }
}

//--------------------------------------------------------------------------------------------------
// Trait Implementations
//--------------------------------------------------------------------------------------------------

impl From<Prompt> for RequestMessages {
    fn from(prompt: Prompt) -> Self {
        let request_messages = prompt
            .into_iter()
            .map(|m| match m {
                PromptMessage::System(SystemMessage { content }) => RequestMessage::System {
                    content,
                    name: None,
                },
                PromptMessage::User(UserMessage { content }) => RequestMessage::User {
                    content,
                    name: None,
                },
                PromptMessage::Assistant(AssistantMessage { content }) => {
                    RequestMessage::Assistant {
                        content,
                        name: None,
                        refusal: None,
                    }
                }
            })
            .collect();

        Self(request_messages)
    }
}
